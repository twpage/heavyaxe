// Generated by CoffeeScript 1.7.1
(function() {
  var getTargetDefinitionWithDefaults;

  window.Brew.Targeting = {
    getPotentialTargets: function(shooter, given_target_def) {
      var enemies_in_view, err_msg, is_ok, m, potential_targets, target_def, traverse_lst, _i, _len, _ref;
      target_def = getTargetDefinitionWithDefaults(given_target_def);
      if (target_def.target_player) {
        enemies_in_view = (function() {
          var _i, _len, _ref, _results;
          _ref = Brew.gameLevel().getMonsters();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (shooter.hasKnowledgeOf(m) && Brew.utils.compareThing(m, Brew.gamePlayer())) {
              _results.push(m);
            }
          }
          return _results;
        })();
      } else {
        enemies_in_view = (function() {
          var _i, _len, _ref, _results;
          _ref = Brew.gameLevel().getMonsters();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (shooter.hasKnowledgeOf(m) && !Brew.utils.compareThing(m, Brew.gamePlayer())) {
              _results.push(m);
            }
          }
          return _results;
        })();
      }
      potential_targets = [];
      for (_i = 0, _len = enemies_in_view.length; _i < _len; _i++) {
        m = enemies_in_view[_i];
        _ref = Brew.Targeting.checkGenericRangedAttack(shooter.coordinates, m.coordinates, target_def), is_ok = _ref[0], err_msg = _ref[1], traverse_lst = _ref[2];
        if (is_ok) {
          potential_targets.push(m);
        }
      }
      return potential_targets;
    },
    checkSimpleRangedAttack: function(attacker, target) {
      var err_msg, is_ok, traverse_lst, _ref;
      if (!attacker.hasKnowledgeOf(target)) {
        return [false, Brew.errors.ATTACK_NOT_KNOWN, []];
      }
      if (!attacker.canView(target.coordinates)) {
        return [false, Brew.errors.ATTACK_NOT_VISIBLE, []];
      }
      _ref = Brew.Targeting.checkGenericRangedAttack(attacker.coordinates, target.coordinates, {
        range: attacker.getAttackRange(),
        blockedByTerrain: true,
        blockedByOtherTargets: true
      }), is_ok = _ref[0], err_msg = _ref[1], traverse_lst = _ref[2];
      console.log(attacker, err_msg);
      return [is_ok, err_msg, traverse_lst];
    },
    showTargeting_Throw: function(item) {
      Brew.Menu.popup.context = "target";
      Brew.Menu.popup.target_context = "throw";
      Brew.Menu.popup.item = item;
      Brew.Menu.popup.target_def = {
        range: 10,
        blockedByTerrain: true,
        blockedByOtherTargets: true,
        requiresTarget: false
      };
      return Brew.Targeting.showTargeting();
    },
    showTargeting: function() {
      var first_target, first_xy, target_def;
      Brew.Display.clearDialogDisplay();
      Brew.Display.drawDisplayAll();
      target_def = getTargetDefinitionWithDefaults(Brew.Menu.popup.target_def);
      Brew.Menu.popup.targets = Brew.Targeting.getPotentialTargets(Brew.gamePlayer(), target_def);
      if (Brew.Menu.popup.targets.length === 0 && target_def.requiresTarget) {
        Brew.msg("No targets");
        return Brew.Input.setInputHandler("popup_to_dismiss");
      } else if (Brew.Menu.popup.targets.length === 0 && (!target_def.requiresTarget)) {
        first_xy = Brew.gamePlayer().coordinates;
        Brew.Targeting.updateAndDrawTargeting(first_xy);
        return Brew.Input.setInputHandler("targeting");
      } else {
        Brew.Menu.popup.target_index = 0;
        first_target = Brew.Menu.popup.targets[0];
        Brew.Targeting.updateAndDrawTargeting(first_target.coordinates);
        return Brew.Input.setInputHandler("targeting");
      }
    },
    updateAndDrawTargeting: function(target_xy) {
      var err_msg, highlight_color, is_ok, last_good_xy, line, old_line, traverse_lst, xy, _i, _j, _len, _len1, _ref, _ref1;
      old_line = (_ref = Brew.Menu.popup.line) != null ? _ref : [];
      for (_i = 0, _len = old_line.length; _i < _len; _i++) {
        xy = old_line[_i];
        Brew.Display.clearHighlightAt(xy);
        Brew.Display.drawMapAt(xy);
      }
      is_ok = true;
      line = [];
      if (Brew.gamePlayer().coordinates.compare(target_xy)) {
        line = [Brew.gamePlayer().coordinates];
      } else {
        _ref1 = Brew.Targeting.checkGenericRangedAttack(Brew.gamePlayer().coordinates, target_xy, Brew.Menu.popup.target_def), is_ok = _ref1[0], err_msg = _ref1[1], traverse_lst = _ref1[2];
        if (is_ok) {
          line = traverse_lst;
        } else if (err_msg === Brew.errors.ATTACK_BLOCKED_TERRAIN || err_msg === Brew.errors.ATTACK_BLOCKED_MONSTER) {
          last_good_xy = traverse_lst[0];
          if (last_good_xy != null) {
            line = Brew.utils.getLineBetweenPoints(Brew.gamePlayer().coordinates, last_good_xy);
            if (line.length > 1) {
              line = line.slice(1, +(line.length - 1) + 1 || 9e9);
            }
          }
          line.push(target_xy);
        } else if (err_msg === Brew.errors.ATTACK_OUT_OF_RANGE) {
          line = [target_xy];
        } else {
          console.error("unhandled targeting error " + err_msg);
        }
      }
      for (_j = 0, _len1 = line.length; _j < _len1; _j++) {
        xy = line[_j];
        highlight_color = is_ok ? Brew.colors.yellow : Brew.colors.red;
        Brew.Display.setHighlightAt(xy, highlight_color);
        Brew.Display.drawMapAt(xy);
      }
      Brew.Menu.popup.line = line;
      Brew.Menu.popup.xy = target_xy;
      Brew.Menu.popup.is_ok = is_ok;
      return Brew.Menu.popup.err_msg = err_msg;
    },
    checkGenericRangedAttack: function(start_xy, target_xy, target_def) {
      var dist, full_traverse_lst, i, last_xy, len, m, t, traverse_lst, xy, _i, _len;
      dist = Brew.utils.dist2d(start_xy, target_xy);
      if (dist > target_def.range) {
        return [false, Brew.errors.ATTACK_OUT_OF_RANGE, []];
      }
      full_traverse_lst = Brew.utils.getLineBetweenPoints(start_xy, target_xy);
      if (full_traverse_lst.length < 2) {
        throw "Traversal path should never be less than 2";
      } else {
        len = full_traverse_lst.length;
        traverse_lst = full_traverse_lst.slice(1, +(len - 1) + 1 || 9e9);
      }
      last_xy = null;
      for (i = _i = 0, _len = traverse_lst.length; _i < _len; i = ++_i) {
        xy = traverse_lst[i];
        t = Brew.gameLevel().getTerrainAt(xy);
        if (t.blocks_walking && target_def.blockedByTerrain) {
          return [false, Brew.errors.ATTACK_BLOCKED_TERRAIN, [last_xy]];
        }
        if (i === (traverse_lst.length - 1) && !target_def.blockedByAnyTarget) {
          continue;
        }
        m = Brew.gameLevel().getMonsterAt(xy);
        if ((m != null) && target_def.blockedByOtherTargets) {
          return [false, Brew.errors.ATTACK_BLOCKED_MONSTER, [last_xy]];
        }
        last_xy = xy;
      }
      return [true, "OK", traverse_lst];
    }
  };

  getTargetDefinitionWithDefaults = function(given_target_def) {
    var _ref, _ref1, _ref2, _ref3, _ref4;
    if (given_target_def.range == null) {
      console.error("need at least range in target definition");
    }
    return {
      range: given_target_def.range,
      blockedByTerrain: (_ref = given_target_def.blockedByTerrain) != null ? _ref : true,
      blockedByOtherTargets: (_ref1 = given_target_def.blockedByOtherTargets) != null ? _ref1 : true,
      target_player: (_ref2 = given_target_def.target_player) != null ? _ref2 : false,
      requiresTarget: (_ref3 = given_target_def.requiresTarget) != null ? _ref3 : true,
      blockedByAnyTarget: (_ref4 = given_target_def.blockedByAnyTarget) != null ? _ref4 : false
    };
  };

}).call(this);

//# sourceMappingURL=targeting.map
