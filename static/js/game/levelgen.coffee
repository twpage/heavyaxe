dummy = {}
counter = Math.floor(ROT.RNG.getUniform() * 1000000)

idGenerator = () ->
	counter += 1
	return counter
	
# class window.LevelGeneratorTester
# 	constructor: (@my_display) ->
# 		@levelgen = new Brew.LevelGenerator(@)
# 		@my_level = null
		
# 	createAndShow: () ->
# 		randseed = (new Date()).getTime()
# 		# randseed = 61903164 # broken one
# 		# randseed = 609209999 # fine
# 		@my_level = @levelgen.create(0, Brew.config.level_tiles_width, Brew.config.level_tiles_height,
# 			{
# 				ambient_light: [0, 0, 0]
# 				noItems: true
# 				levelGen: true
# 			},
# 			randseed
# 		)
		
# 		@showMyMap()
		
# 	showMyMap: () ->
# 		for row_y in [0..@my_display.getOptions().height-1]
# 			for col_x in [0..@my_display.getOptions().width-1]
# 				xy = new Coordinate(col_x, row_y)
# 				t = @my_level.getTerrainAt(xy)
# 				@my_display.draw(xy.x, xy.y, t.code, ROT.Color.toHex(t.color), ROT.Color.toHex(t.bgcolor))
	
Brew.LevelGenerator = 
	createLevel: (depth, width, height, levelgen_options) ->
		
		ROT.RNG.setSeed(Brew.Game.seed + depth)
		
		# instantiate level object
		level = new Brew.Level(depth, width, height, levelgen_options)

		# fill level with base terrain
		buildTerrain(level)
		
		# calculate walkable tiles, etc
		level.calcTerrainNavigation()

		setupExitEntrancePortals(level)
		setupMonsters(level)
		setupRunes(level)
		setupScrolls(level)

		return level

buildTerrain = (level) ->
	# maze = new ROT.Map.EllerMaze(level.width + 2, level.height + 2)
	maze = new ROT.Map.EllerMaze(level.width, level.height)
	walls = []
	one_off_xy = new Coordinate(1, 1)

	maze.create( (x, y, value) =>
		if value == 0
			terrain = "FLOOR"
		else
			terrain = "WALL"

		# if x == 0 or x == level.width+1 or y == 0 or y == level.height+1
		# 	return

		xy = new Coordinate(x, y)
		# real_xy = xy.subtract(one_off_xy) # ignoring walls generated by that maze algorithm
		# console.log(xy, real_xy)
		level.setTerrainAt(xy, Brew.terrainFactory(terrain))
		if terrain == "WALL"
			walls.push(xy)
	)

	# find dead-ends
	blocking_walls = {}
	isOuterWall = (some_xy) =>
		return some_xy.x == 0 or some_xy.x == level.width-1 or some_xy.y == 0 or some_xy.y == level.height-1

	for wall_xy in walls
		open_floor = 0
		for nxy in wall_xy.getAdjacent()
			if not level.checkValid(nxy)
				continue

			t = level.getTerrainAt(nxy)
			if not t?
				console.log(level.checkValid(nxy), t, nxy)

			if Brew.utils.isTerrain(t, "FLOOR")
				open_floor += 1

		if open_floor > 0
			blocking_walls[wall_xy.toKey()] = open_floor

	good_blocks = []
	for own key, open_floor of blocking_walls
		xy = keyToCoord(key)
		t = level.getTerrainAt(xy)
		
		# 2s are what we really care about
		if open_floor == 2
			# need to identify walls that have ADJACENT ONLY openings
			adjacent_walls = (nxy for nxy in xy.getAdjacent() when Brew.utils.isTerrain(level.getTerrainAt(nxy), "FLOOR"))
			if adjacent_walls.length != 2
				console.error("We failed at math!")

			# take the coordinate difference of the two floors
			adjacent_test_xy = adjacent_walls[0].subtract(adjacent_walls[1])

			# if they are adjacent, they should be off by 0, 2 or 2, 0 -- ONLY
			if Math.abs(adjacent_test_xy.x) == 1 or Math.abs(adjacent_test_xy.y) == 1
				continue

			# now we should be left with nice path-blocking walls only
			good_blocks.push(xy)

		# add some outerwalls that only have 1 floor next to them
		else if open_floor == 1 and isOuterWall(xy)
			good_blocks.push(xy)

	num_walls = good_blocks.length
	good_blocks = good_blocks.randomize()

	# let's use some of them to make torches!
	# for i in [0..Brew.config.num_torches-1]
	# 	level.setTerrainAt(good_blocks[i], Brew.terrainFactory("WALL_TORCH"))

	# now let's blow some of them up!
	num_broken_walls = Math.floor(num_walls*Brew.config.break_the_walls_down)
	good_blocks = good_blocks.randomize()

	for xy in good_blocks[0..num_broken_walls-1]
		level.setTerrainAt(xy, Brew.terrainFactory("FLOOR", {code: ','}))


	return true

setupScrolls = (level) ->
	num_scrolls = Brew.config.scrolls_per_level
		
	# figure out potential monsters for this depth
	potential_items = []
	for own def_id, idef of Brew.item_def
		if not idef.min_depth?
			continue

		if idef.group != Brew.group.scroll.id
			continue

		else
			min_depth = idef.min_depth

		if min_depth > level.depth
			continue

		# include all items at minimum depth onwards for now - no real weak items?
		# if min_depth < (level.depth - Brew.config.include_items_depth_lag)
		# 	continue

		potential_items.push(def_id)

	if potential_items.length < 1
		return false
		
	# no weighting for scrolls (yet)
	for i in [1..num_scrolls]
		xy = level.getRandomWalkableLocation()
		def_id = potential_items.random()
		item = Brew.itemFactory(def_id)
		level.setItemAt(xy, item)

	return true

setupRunes = (level) ->
	num_runes = Brew.config.runes_per_level
		
	# figure out potential monsters for this depth
	potential_items = []
	for own def_id, idef of Brew.item_def
		if not idef.min_depth?
			continue

		if idef.group != Brew.group.rune.id
			continue

		else
			min_depth = idef.min_depth

		if min_depth > level.depth
			continue

		# include all items at minimum depth onwards for now - no real weak items?
		# if min_depth < (level.depth - Brew.config.include_items_depth_lag)
		# 	continue

		potential_items.push(def_id)

	if potential_items.length < 1
		return false
		
	# no weighting for runes (yet)
	added_runes = []
	for i in [1..num_runes]
		xy = level.getRandomWalkableLocation()
		def_id = potential_items.random()
		item = Brew.itemFactory(def_id)
		level.setItemAt(xy, item)
		added_runes.push(item)
	
	# make sure we have at least one rune of recall per level
	has_recall_rune = (i for i in added_runes when i.itemType == Brew.ItemType.type_of.scroll.recall.id).length > 0
	if not has_recall_rune
		xy = level.getRandomWalkableLocation()
		item = Brew.itemFactory("RUNE_RECALL")
		level.setItemAt(xy, item)
		added_runes.push(item)

	# go through Runes of Portal and create matching portals for them
	setupRunesOfPortal(level)

	return true

setupRunesOfPortal = (level) ->
	# create pairs for each portal rune

	portal_runes = []
	for item in level.getItems()
		if item.group != Brew.group.rune.id
			continue

		if item.itemType != Brew.ItemType.type_of.rune.portal.id
			continue

		portal_runes.push(item)

	for rune in portal_runes
		# create a new one at a random location
		while true
			xy = level.getRandomWalkableLocation()
			dist = Brew.utils.dist2d(xy, rune.coordinates)
			if dist < 5
				continue

			new_rune = Brew.itemFactory("RUNE_PORTAL")
			level.setItemAt(xy, new_rune)
			rune.pair_xy = new_rune.coordinates
			new_rune.pair_xy = rune.coordinates
			break

	return true

setupRunesOfHealth = (level) ->
	u = ROT.RNG.getUniform()
	if u < Brew.config.chance_of_health_rune
		xy = level.getRandomWalkableLocation()
		level.setItemAt(xy, Brew.itemFactory("RUNE_HEALTH"))


		

getNearby = (level, center_xy) ->
	potentials = []
	for xy in center_xy.getSurrounding()
		if not level.checkValid(xy)
			continue

		t = level.getTerrainAt(xy)
		if t.blocks_walking
			continue

		i = level.getItemAt(xy)
		if i?
			continue

		m = level.getMonsterAt(xy)
		if m?
			continue

		potentials.push(xy)

	if potentials.length == 0
		return null
	else
		return potentials.random()


setupMonsters = (level) ->
	num_monsters = Brew.config.monsters_per_level
	
	# figure out potential monsters for this depth
	# where level depth is AT LEAST min_depth, 
	# and *Brew.config.include_monsters_depth_lag* determines how quickly monsters drop off
	potential_monsters = []
	for own def_id, mdef of Brew.monster_def
		if not mdef.min_depth?
			continue

		if mdef.min_depth > level.depth
			continue

		if mdef.min_depth < (level.depth - Brew.config.include_monsters_depth_lag)
			continue

		potential_monsters.push(def_id)

	## error out if we have no monsters
	## this can be overcome by either adding deeper monsters, increasing min_depth on existing monsters,
	## or increasing the include_monsters_depth_lag config parameter
	if potential_monsters.length == 0
		console.error("not enough monsters defined for this depth")

	# add up all monster raritys by weight
	weighted = {}
	for def_id in potential_monsters
		weighted[def_id] = Brew.monster_def[def_id].rarity
	
	total = (wgt for own d, wgt of weighted).reduce (t, s) -> t + s

	last_wgt = 0
	for own def_id, wgt of weighted
		new_wgt = last_wgt + (wgt / total)
		weighted[def_id] = new_wgt
		last_wgt = new_wgt
	
	# add monsters weightederly
	for i in [1..num_monsters]
		tries = 0
		xy = null
		while tries < 25
			xy = level.getRandomWalkableLocation()
			dist_to_start = Brew.utils.dist2d(level.start_xy, xy)

			if dist_to_start < 3
				xy = null
				tries += 1
			else
				break

		if not xy
			continue

		u = ROT.RNG.getUniform()
		for own def_id, wgt of weighted
			if u < wgt
				monster = Brew.monsterFactory(def_id)
				# console.log("added monster #{def_id}")
				level.setMonsterAt(xy, monster)
					
				break

	# add boss at final depth
	if level.depth == Brew.config.max_depth - 1
		xy = level.getRandomWalkableLocation()
		level.setMonsterAt(xy, Brew.monsterFactory("BOSS_MONSTER"))

	# add tutorials at first depth
	# if level.depth == 0
	# 	for i in [0..Brew.tutorial_texts.length-1]
	# 		xy = level.getRandomWalkableLocation()
	# 		level.setItemAt(xy, Brew.itemFactory("INFO_POINT", {name: "Help", description: Brew.tutorial_texts[i]}))

	return true
	
setupExitEntrancePortals = (level) ->
	# entrance and exit
	level.start_xy = level.getRandomWalkableLocation()

	return true

