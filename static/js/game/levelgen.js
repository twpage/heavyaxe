// Generated by CoffeeScript 1.7.1
(function() {
  var buildTerrain, counter, dummy, getNearby, idGenerator, setupExitEntrancePortals, setupMonsters, setupRunes, setupRunesOfHealth, setupRunesOfPortal, setupScrolls,
    __hasProp = {}.hasOwnProperty;

  dummy = {};

  counter = Math.floor(ROT.RNG.getUniform() * 1000000);

  idGenerator = function() {
    counter += 1;
    return counter;
  };

  Brew.LevelGenerator = {
    createLevel: function(depth, width, height, levelgen_options) {
      var level;
      ROT.RNG.setSeed(Brew.Game.seed + depth);
      level = new Brew.Level(depth, width, height, levelgen_options);
      buildTerrain(level);
      level.calcTerrainNavigation();
      setupExitEntrancePortals(level);
      setupMonsters(level);
      setupRunes(level);
      setupScrolls(level);
      return level;
    }
  };

  buildTerrain = function(level) {
    var adjacent_test_xy, adjacent_walls, blocking_walls, good_blocks, isOuterWall, key, maze, num_broken_walls, num_walls, nxy, one_off_xy, open_floor, t, wall_xy, walls, xy, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    maze = new ROT.Map.EllerMaze(level.width, level.height);
    walls = [];
    one_off_xy = new Coordinate(1, 1);
    maze.create((function(_this) {
      return function(x, y, value) {
        var terrain, xy;
        if (value === 0) {
          terrain = "FLOOR";
        } else {
          terrain = "WALL";
        }
        xy = new Coordinate(x, y);
        level.setTerrainAt(xy, Brew.terrainFactory(terrain));
        if (terrain === "WALL") {
          return walls.push(xy);
        }
      };
    })(this));
    blocking_walls = {};
    isOuterWall = (function(_this) {
      return function(some_xy) {
        return some_xy.x === 0 || some_xy.x === level.width - 1 || some_xy.y === 0 || some_xy.y === level.height - 1;
      };
    })(this);
    for (_i = 0, _len = walls.length; _i < _len; _i++) {
      wall_xy = walls[_i];
      open_floor = 0;
      _ref = wall_xy.getAdjacent();
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        nxy = _ref[_j];
        if (!level.checkValid(nxy)) {
          continue;
        }
        t = level.getTerrainAt(nxy);
        if (t == null) {
          console.log(level.checkValid(nxy), t, nxy);
        }
        if (Brew.utils.isTerrain(t, "FLOOR")) {
          open_floor += 1;
        }
      }
      if (open_floor > 0) {
        blocking_walls[wall_xy.toKey()] = open_floor;
      }
    }
    good_blocks = [];
    for (key in blocking_walls) {
      if (!__hasProp.call(blocking_walls, key)) continue;
      open_floor = blocking_walls[key];
      xy = keyToCoord(key);
      t = level.getTerrainAt(xy);
      if (open_floor === 2) {
        adjacent_walls = (function() {
          var _k, _len2, _ref1, _results;
          _ref1 = xy.getAdjacent();
          _results = [];
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            nxy = _ref1[_k];
            if (Brew.utils.isTerrain(level.getTerrainAt(nxy), "FLOOR")) {
              _results.push(nxy);
            }
          }
          return _results;
        })();
        if (adjacent_walls.length !== 2) {
          console.error("We failed at math!");
        }
        adjacent_test_xy = adjacent_walls[0].subtract(adjacent_walls[1]);
        if (Math.abs(adjacent_test_xy.x) === 1 || Math.abs(adjacent_test_xy.y) === 1) {
          continue;
        }
        good_blocks.push(xy);
      } else if (open_floor === 1 && isOuterWall(xy)) {
        good_blocks.push(xy);
      }
    }
    num_walls = good_blocks.length;
    good_blocks = good_blocks.randomize();
    num_broken_walls = Math.floor(num_walls * Brew.config.break_the_walls_down);
    good_blocks = good_blocks.randomize();
    _ref1 = good_blocks.slice(0, +(num_broken_walls - 1) + 1 || 9e9);
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      xy = _ref1[_k];
      level.setTerrainAt(xy, Brew.terrainFactory("FLOOR", {
        code: ','
      }));
    }
    return true;
  };

  setupScrolls = function(level) {
    var def_id, i, idef, item, min_depth, num_scrolls, potential_items, xy, _i, _ref;
    num_scrolls = Brew.config.scrolls_per_level;
    potential_items = [];
    _ref = Brew.item_def;
    for (def_id in _ref) {
      if (!__hasProp.call(_ref, def_id)) continue;
      idef = _ref[def_id];
      if (idef.min_depth == null) {
        continue;
      }
      if (idef.group !== Brew.group.scroll.id) {
        continue;
      } else {
        min_depth = idef.min_depth;
      }
      if (min_depth > level.depth) {
        continue;
      }
      potential_items.push(def_id);
    }
    if (potential_items.length < 1) {
      return false;
    }
    for (i = _i = 1; 1 <= num_scrolls ? _i <= num_scrolls : _i >= num_scrolls; i = 1 <= num_scrolls ? ++_i : --_i) {
      xy = level.getRandomWalkableLocation();
      def_id = potential_items.random();
      item = Brew.itemFactory(def_id);
      level.setItemAt(xy, item);
    }
    return true;
  };

  setupRunes = function(level) {
    var added_runes, def_id, has_recall_rune, i, idef, item, min_depth, num_runes, potential_items, xy, _i, _ref;
    num_runes = Brew.config.runes_per_level;
    potential_items = [];
    _ref = Brew.item_def;
    for (def_id in _ref) {
      if (!__hasProp.call(_ref, def_id)) continue;
      idef = _ref[def_id];
      if (idef.min_depth == null) {
        continue;
      }
      if (idef.group !== Brew.group.rune.id) {
        continue;
      } else {
        min_depth = idef.min_depth;
      }
      if (min_depth > level.depth) {
        continue;
      }
      potential_items.push(def_id);
    }
    if (potential_items.length < 1) {
      return false;
    }
    added_runes = [];
    for (i = _i = 1; 1 <= num_runes ? _i <= num_runes : _i >= num_runes; i = 1 <= num_runes ? ++_i : --_i) {
      xy = level.getRandomWalkableLocation();
      def_id = potential_items.random();
      item = Brew.itemFactory(def_id);
      level.setItemAt(xy, item);
      added_runes.push(item);
    }
    has_recall_rune = ((function() {
      var _j, _len, _results;
      _results = [];
      for (_j = 0, _len = added_runes.length; _j < _len; _j++) {
        i = added_runes[_j];
        if (i.itemType === Brew.ItemType.type_of.scroll.recall.id) {
          _results.push(i);
        }
      }
      return _results;
    })()).length > 0;
    if (!has_recall_rune) {
      xy = level.getRandomWalkableLocation();
      item = Brew.itemFactory("RUNE_RECALL");
      level.setItemAt(xy, item);
      added_runes.push(item);
    }
    setupRunesOfPortal(level);
    return true;
  };

  setupRunesOfPortal = function(level) {
    var dist, item, new_rune, portal_runes, rune, xy, _i, _j, _len, _len1, _ref;
    portal_runes = [];
    _ref = level.getItems();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item.group !== Brew.group.rune.id) {
        continue;
      }
      if (item.itemType !== Brew.ItemType.type_of.rune.portal.id) {
        continue;
      }
      portal_runes.push(item);
    }
    for (_j = 0, _len1 = portal_runes.length; _j < _len1; _j++) {
      rune = portal_runes[_j];
      while (true) {
        xy = level.getRandomWalkableLocation();
        dist = Brew.utils.dist2d(xy, rune.coordinates);
        if (dist < 5) {
          continue;
        }
        new_rune = Brew.itemFactory("RUNE_PORTAL");
        level.setItemAt(xy, new_rune);
        rune.pair_xy = new_rune.coordinates;
        new_rune.pair_xy = rune.coordinates;
        break;
      }
    }
    return true;
  };

  setupRunesOfHealth = function(level) {
    var u, xy;
    u = ROT.RNG.getUniform();
    if (u < Brew.config.chance_of_health_rune) {
      xy = level.getRandomWalkableLocation();
      return level.setItemAt(xy, Brew.itemFactory("RUNE_HEALTH"));
    }
  };

  getNearby = function(level, center_xy) {
    var i, m, potentials, t, xy, _i, _len, _ref;
    potentials = [];
    _ref = center_xy.getSurrounding();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      xy = _ref[_i];
      if (!level.checkValid(xy)) {
        continue;
      }
      t = level.getTerrainAt(xy);
      if (t.blocks_walking) {
        continue;
      }
      i = level.getItemAt(xy);
      if (i != null) {
        continue;
      }
      m = level.getMonsterAt(xy);
      if (m != null) {
        continue;
      }
      potentials.push(xy);
    }
    if (potentials.length === 0) {
      return null;
    } else {
      return potentials.random();
    }
  };

  setupMonsters = function(level) {
    var d, def_id, dist_to_start, i, last_wgt, mdef, monster, new_wgt, num_monsters, potential_monsters, total, tries, u, weighted, wgt, xy, _i, _j, _len, _ref;
    num_monsters = Brew.config.monsters_per_level;
    potential_monsters = [];
    _ref = Brew.monster_def;
    for (def_id in _ref) {
      if (!__hasProp.call(_ref, def_id)) continue;
      mdef = _ref[def_id];
      if (mdef.min_depth == null) {
        continue;
      }
      if (mdef.min_depth > level.depth) {
        continue;
      }
      if (mdef.min_depth < (level.depth - Brew.config.include_monsters_depth_lag)) {
        continue;
      }
      potential_monsters.push(def_id);
    }
    if (potential_monsters.length === 0) {
      console.error("not enough monsters defined for this depth");
    }
    weighted = {};
    for (_i = 0, _len = potential_monsters.length; _i < _len; _i++) {
      def_id = potential_monsters[_i];
      weighted[def_id] = Brew.monster_def[def_id].rarity;
    }
    total = ((function() {
      var _results;
      _results = [];
      for (d in weighted) {
        if (!__hasProp.call(weighted, d)) continue;
        wgt = weighted[d];
        _results.push(wgt);
      }
      return _results;
    })()).reduce(function(t, s) {
      return t + s;
    });
    last_wgt = 0;
    for (def_id in weighted) {
      if (!__hasProp.call(weighted, def_id)) continue;
      wgt = weighted[def_id];
      new_wgt = last_wgt + (wgt / total);
      weighted[def_id] = new_wgt;
      last_wgt = new_wgt;
    }
    for (i = _j = 1; 1 <= num_monsters ? _j <= num_monsters : _j >= num_monsters; i = 1 <= num_monsters ? ++_j : --_j) {
      tries = 0;
      xy = null;
      while (tries < 25) {
        xy = level.getRandomWalkableLocation();
        dist_to_start = Brew.utils.dist2d(level.start_xy, xy);
        if (dist_to_start < 3) {
          xy = null;
          tries += 1;
        } else {
          break;
        }
      }
      if (!xy) {
        continue;
      }
      u = ROT.RNG.getUniform();
      for (def_id in weighted) {
        if (!__hasProp.call(weighted, def_id)) continue;
        wgt = weighted[def_id];
        if (u < wgt) {
          monster = Brew.monsterFactory(def_id);
          level.setMonsterAt(xy, monster);
          break;
        }
      }
    }
    if (level.depth === Brew.config.max_depth - 1) {
      xy = level.getRandomWalkableLocation();
      level.setMonsterAt(xy, Brew.monsterFactory("BOSS_MONSTER"));
    }
    return true;
  };

  setupExitEntrancePortals = function(level) {
    level.start_xy = level.getRandomWalkableLocation();
    return true;
  };

}).call(this);

//# sourceMappingURL=levelgen.map
