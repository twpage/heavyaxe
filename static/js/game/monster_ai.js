// Generated by CoffeeScript 1.7.1
(function() {
  window.Brew.MonsterAI = (function() {
    function MonsterAI(game) {
      this.game = game;
      this.id = null;
    }

    MonsterAI.prototype.msg = function(text) {
      return this.game.msg(text);
    };

    MonsterAI.prototype.doMonsterTurn = function(monster) {
      var result;
      if (monster.hasFlag(Brew.flags.is_stunned.id)) {
        return false;
      }
      this.updateState(monster);
      result = this.getAction(monster);
      monster.last_xy = monster.coordinates;
      this.game.execMonsterTurnResult(monster, result);
      return true;
    };

    MonsterAI.prototype.updateState = function(monster) {
      var horde_sense_player, is_angry, is_hunting, keeps_distance, me_sense_player, sense_player, _ref;
      me_sense_player = monster.hasKnowledgeOf(this.game.my_player);
      horde_sense_player = monster.horde != null ? monster.horde.hasKnowledgeOf(this.game.my_player) : false;
      sense_player = me_sense_player || horde_sense_player;
      is_hunting = false;
      if (monster.status !== Brew.monster_status.ESCAPE && monster.hasFlag(Brew.flags.flees_when_wounded.id)) {
        if (!monster.getStat(Brew.stat.health).isMax()) {
          this.msg(monster.name + " flees!");
          monster.status = Brew.monster_status.ESCAPE;
          return true;
        }
      }
      if (monster.status === Brew.monster_status.SLEEP) {

      } else if ((_ref = monster.status) === Brew.monster_status.WANDER || _ref === Brew.monster_status.GUARD) {
        if (sense_player) {
          monster.status = Brew.monster_status.HUNT;
          if (monster.hasFlag(Brew.flags.is_passive.id)) {
            monster.sight_radius = monster.sight_radius * 2;
          }
          is_hunting = true;
        }
      } else if (monster.status === Brew.monster_status.HUNT) {
        if (!sense_player) {
          if (monster.canView(monster.last_player_xy)) {
            monster.giveup = (monster != null ? monster.giveup : void 0) ? monster.giveup + 1 : 1;
            if (monster.giveup > 4) {
              this.giveUpHunting(monster);
            }
          }
        } else {
          is_hunting = true;
        }
      } else if (monster.status === Brew.monster_status.ESCAPE) {
        if (sense_player) {
          this.game.updatePathMapsFor(monster, true);
        }
        if (monster.hp === monster.maxhp) {
          monster.status = Brew.monster_status.HUNT;
        }
      }
      if (is_hunting) {
        monster.giveup = 0;
        monster.last_player_xy = this.game.my_player.coordinates;
        is_angry = monster.hasFlag(Brew.flags.is_angry.id);
        keeps_distance = is_angry ? false : monster.hasFlag(Brew.flags.keeps_distance.id);
        this.game.updatePathMapsFor(monster, keeps_distance);
      }
      return true;
    };

    MonsterAI.prototype.giveUpHunting = function(monster) {
      if (monster.hasFlag(Brew.flags.is_passive.id)) {
        monster.status = Brew.monster_status.GUARD;
        monster.sight_radius = monster.sight_radius / 2;
      } else {
        monster.status = Brew.monster_status.WANDER;
      }
      Brew.Display.showFloatingTextAbove(monster.coordinates, "?", Brew.colors.red);
      monster.giveup = 0;
      return true;
    };

    MonsterAI.prototype.getAction = function(monster) {
      var decision, decision_result, horde_sense_player, is_angry, is_immobile, keepdistance_xy, keeping_distance, keeps_distance, me_sense_player, monster_at, result, sense_player, special_ability;
      me_sense_player = monster.hasKnowledgeOf(this.game.my_player);
      horde_sense_player = monster.horde != null ? monster.horde.hasKnowledgeOf(this.game.my_player) : false;
      sense_player = me_sense_player || horde_sense_player;
      is_immobile = monster.hasFlag(Brew.flags.is_immobile.id);
      result = {
        action: null,
        xy: monster.coordinates,
        target: null
      };
      if (monster.status === Brew.monster_status.SLEEP) {
        result.action = "sleep";
      } else if (monster.status === Brew.monster_status.GUARD) {
        result.action = "wait";
        result.note = "guard";
      } else if (monster.status === Brew.monster_status.WANDER) {
        if (monster.giveup > 4 || ((monster.wander_xy != null) && monster.coordinates.compare(monster.wander_xy))) {
          monster.giveup = 0;
          monster.wander_xy = null;
        }
        if (ROT.RNG.getUniform() < 0.20) {
          monster.giveup = 0;
          monster.wander_xy = null;
        }
        result.action = "move";
        result.xy = this.getWanderMove(monster);
      } else if ((monster.status === Brew.monster_status.ESCAPE) || monster.hasFlag(Brew.flags.is_scared.id)) {
        result.action = "move";
        result.xy = this.getMoveAwayFromPlayer(monster);
      } else if (monster.status === Brew.monster_status.HUNT && is_immobile) {
        if (sense_player && this.game.canAttack(monster, this.game.my_player)) {
          result.action = "attack";
          result.xy = this.game.my_player.coordinates;
          result.target = this.game.my_player;
        } else {
          result.action = "wait";
          result.note = "immobile hunt";
        }
      } else if (monster.status === Brew.monster_status.HUNT && (!is_immobile)) {
        is_angry = monster.hasFlag(Brew.flags.is_angry.id);
        keeps_distance = is_angry ? false : monster.hasFlag(Brew.flags.keeps_distance.id);
        if (monster.hasFlag(Brew.flags.attacks_in_group.id) && this.checkAttackGroup(monster)) {
          keeps_distance = false;
        }
        if (sense_player) {
          keeping_distance = false;
          if (keeps_distance) {
            decision_result = this.getKeepDistanceDirection(monster);
            decision = decision_result.direction;
            if (decision === "forward") {
              keepdistance_xy = this.getMoveTowardsPlayer(monster);
            } else if (decision === "back") {
              keepdistance_xy = this.getMoveAwayFromPlayer(monster);
            } else {
              keepdistance_xy = null;
            }
            if ((keepdistance_xy != null) && !keepdistance_xy.compare(monster.coordinates)) {
              result.action = "move";
              result.xy = keepdistance_xy;
              result.note = "successfull keep distance";
              keeping_distance = true;
            }
          }
          if (!keeping_distance) {
            special_ability = this.canUseSpecialAbility(monster);
            if (special_ability) {
              result.action = "special";
              this.doSpecialAbility(monster, special_ability);
            } else if (this.game.canAttack(monster, this.game.my_player)) {
              result.action = "attack";
              result.xy = this.game.my_player.coordinates;
              result.target = this.game.my_player;
            } else if (keeps_distance) {
              console.log("keeping distance - stand");
              result.action = "stand";
            } else {
              result.action = "move";
              result.xy = this.getMoveTowardsPlayer(monster);
            }
          }
        } else {
          result.action = "move";
          result.xy = this.game.findMove_AStar(monster, monster.coordinates, monster.last_player_xy);
        }
      }
      if (result.action === "move" && is_immobile) {
        result.action = "wait";
        result.note = "immobile can't move";
      } else if (result.action === "wait") {
        monster.giveup = (monster != null ? monster.giveup : void 0) ? monster.giveup + 1 : 1;
      } else if (result.action === "move") {
        if (result.xy == null) {
          result.action = "wait";
          result.note = "no valid xy on move action";
          monster.giveup = (monster != null ? monster.giveup : void 0) ? monster.giveup + 1 : 1;
        } else {
          monster_at = this.game.my_level.getMonsterAt(result.xy);
          if (monster_at != null) {
            if (monster_at.group === "player") {
              result.action = "attack";
              result.target = this.game.my_player;
            } else if (monster.status === Brew.monster_status.ESCAPE && monster_at.status === Brew.monster_status.ESCAPE) {
              monster_at.pathmaps[Brew.paths.from_player] = monster.pathmaps[Brew.paths.from_player];
              result.action = "wait";
              result.note = "escape blocked by non-player monster";
            } else {
              result.action = "wait";
              result.xy = null;
              result.target = null;
              result.note = "move blocked by non-player monster";
            }
          }
        }
      }
      return result;
    };

    MonsterAI.prototype.checkAttackGroup = function(monster) {
      var allies, monster_id, _i, _len, _ref;
      allies = [];
      _ref = monster.knowledge;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        monster_id = _ref[_i];
        monster = Brew.gameLevel().getMonsterById(monster_id);
        if (monster == null) {
          continue;
        }
        if (!Brew.utils.compareThing(monster, Brew.gamePlayer())) {
          allies.push(monster);
        }
      }
      return allies.length >= 1;
    };

    MonsterAI.prototype.getWanderMove = function(monster) {
      var next_xy;
      if (monster.wander_xy == null) {
        monster.wander_xy = this.game.my_level.getRandomWalkableLocation();
      } else if (monster.wander_xy.compare(monster.coordinates)) {
        monster.wander_xy = this.game.my_level.getRandomWalkableLocation();
      }
      next_xy = this.game.findMove_AStar(monster, monster.coordinates, monster.wander_xy);
      return next_xy;
    };

    MonsterAI.prototype.getKeepDistanceDirection = function(monster) {
      var direction, stand_value;
      stand_value = monster.pathmaps[Brew.paths.to_player][monster.coordinates.toKey()];
      direction = null;
      if (stand_value < monster.keeps_distance) {
        direction = "back";
      } else if (stand_value > monster.keeps_distance) {
        direction = "forward";
      } else {
        direction = "stand";
      }
      return {
        direction: direction,
        stand_value: stand_value,
        keeps_distance: monster.keeps_distance
      };
    };

    MonsterAI.prototype.getMoveAwayFromPlayer = function(monster) {
      var m, next_xy, path_xy;
      next_xy = null;
      if (monster.pathmaps[Brew.paths.from_player] == null) {
        console.log("monster tried to run away without escape map");
        next_xy = getWanderMove(monster);
      } else {
        path_xy = Brew.PathMap.getDownhillNeighbor(monster.pathmaps[Brew.paths.from_player], monster.coordinates).xy;
        if (path_xy == null) {
          console.log("getMoveAwayFromPlayer null path");
        } else {
          m = this.game.my_level.getMonsterAt(path_xy);
          if ((m != null) && m.group !== "player" && !Brew.utils.compareThing(monster, m)) {
            console.log("getMoveAwayFromPlayer monster collision");
          } else {
            next_xy = path_xy;
          }
        }
      }
      return next_xy;
    };

    MonsterAI.prototype.getMoveTowardsPlayer = function(monster) {
      var m, next_xy, path_xy;
      next_xy = null;
      if (this.game.pathmaps[Brew.paths.to_player] == null) {
        console.log("monster tried to move towards player without map");
      } else {
        path_xy = Brew.PathMap.getDownhillNeighbor(this.game.pathmaps[Brew.paths.to_player], monster.coordinates).xy;
        m = path_xy != null ? this.game.my_level.getMonsterAt(path_xy) : null;
        if ((path_xy == null) || ((m != null) && m.group !== "player")) {
          next_xy = this.game.findMove_AStar(monster, monster.coordinates, this.game.my_player.coordinates);
          console.log(("astar override for " + monster.id + ": ") + next_xy);
        } else {
          next_xy = path_xy;
        }
      }
      return next_xy;
    };

    MonsterAI.prototype.canUseSpecialAbility = function(monster) {
      var can_use;
      can_use = null;
      return can_use;
    };

    MonsterAI.prototype.doSpecialAbility = function(monster, special_ability) {
      if (special_ability === Brew.flags.summons_zombies.id) {
        return true;
      } else {
        console.log("unrecognized special ability: " + special_ability);
        return false;
      }
    };

    return MonsterAI;

  })();

}).call(this);

//# sourceMappingURL=monster_ai.map
