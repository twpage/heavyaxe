// Generated by CoffeeScript 1.7.1
(function() {
  var debug, highlights, initDialogDisplay, initLayerDisplay, input_handler, messagelog, my_dialog_display, my_dialog_tile_height, my_dialog_tile_width, my_display, my_layer_display, my_tile_height, my_tile_width, my_view, panel_offsets,
    __hasProp = {}.hasOwnProperty;

  my_display = null;

  my_layer_display = null;

  my_dialog_display = null;

  my_tile_width = null;

  my_tile_height = null;

  my_dialog_tile_width = null;

  my_dialog_tile_height = null;

  my_view = new Coordinate(0, 0);

  input_handler = null;

  messagelog = [];

  panel_offsets = {
    "game": new Coordinate(Brew.panels.game.x, Brew.panels.game.y),
    "playerinfo": new Coordinate(Brew.panels.playerinfo.x, Brew.panels.playerinfo.y)
  };

  debug = {
    fov: {},
    pathmaps: {}
  };

  highlights = {};

  window.Brew.Display = {
    init: function(display_info) {
      my_display = display_info["game"];
      my_layer_display = display_info["layer"];
      my_dialog_display = display_info["dialog"];
      my_tile_width = my_display.getContainer().width / Brew.panels.full.width;
      my_tile_height = my_display.getContainer().height / Brew.panels.full.height;
      my_dialog_tile_width = my_dialog_display.getContainer().width / Brew.config.dialog_display.width;
      my_dialog_tile_height = my_dialog_display.getContainer().height / Brew.config.dialog_display.height;
      return setTimeout((function(_this) {
        return function() {
          initLayerDisplay();
          return initDialogDisplay();
        };
      })(this), 30);
    },
    dialogDisplay: function() {
      return my_dialog_display;
    },
    layerDisplay: function() {
      return my_layer_display;
    },
    gameDisplay: function() {
      return my_display;
    },
    debug: {},
    getHighlightAt: function(xy) {
      var _ref;
      return (_ref = highlights[xy.toKey()]) != null ? _ref : null;
    },
    clearHighlightAt: function(xy) {
      delete highlights[xy.toKey()];
      return true;
    },
    setHighlightAt: function(xy, color) {
      highlights[xy.toKey()] = color;
      return true;
    },
    clearHighlights: function() {
      highlights = {};
      return true;
    },
    appendBlanksToString: function(text, max_length) {
      var black_hex, i, num_spaces, spaces;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      num_spaces = max_length - text.length;
      spaces = ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= num_spaces ? _i <= num_spaces : _i >= num_spaces; i = 0 <= num_spaces ? ++_i : --_i) {
          _results.push("_");
        }
        return _results;
      })()).join("");
      return text + ("%c{" + black_hex + "}" + spaces);
    },
    screenToMap: function(screen_xy) {
      var map_xy;
      if (Brew.Display.getPanelAt(screen_xy) !== "game") {
        return null;
      } else {
        map_xy = screen_xy.subtract(panel_offsets["game"]).add(my_view);
        return map_xy;
      }
    },
    mapToScreen: function(map_xy) {
      var screen_xy;
      screen_xy = map_xy.subtract(my_view).add(panel_offsets["game"]);
      if (Brew.Display.getPanelAt(screen_xy) !== "game") {
        return null;
      } else {
        return screen_xy;
      }
    },
    gameToDialog: function(game_xy) {
      var dx, dy;
      dx = Math.floor(game_xy.x * Brew.config.dialog_display.xconvert);
      dy = Math.floor(game_xy.y * Brew.config.dialog_display.yconvert);
      return new Coordinate(dx, dy);
    },
    setDialogDisplayTransparency: function(alpha) {
      return my_dialog_display._context.globalAlpha = alpha;
    },
    resetDialogDisplayTransparency: function() {
      return my_dialog_display._context.globalAlpha = 1;
    },
    drawDisplayAll: function(options) {
      this.clearLayerDisplay();
      this.drawGamePanel(options);
      this.drawPlayerInfoPanel();
      return this.drawOnScreenInfo();
    },
    drawOnPanel: function(panel_name, x, y, code, forecolor, bgcolor) {
      var panel_x, panel_y;
      panel_x = panel_offsets[panel_name].x + x;
      panel_y = panel_offsets[panel_name].y + y;
      my_display.draw(panel_x, panel_y, code, forecolor, bgcolor);
      return true;
    },
    drawTextOnPanel: function(panel_name, x, y, text, max_width) {
      var panel_x, panel_y;
      panel_x = panel_offsets[panel_name].x + x;
      panel_y = panel_offsets[panel_name].y + y;
      my_display.drawText(panel_x, panel_y, text, max_width);
      return true;
    },
    drawSeparatedBarOnPanel: function(panel_name, start_x, start_y, max_tiles, current_amount, max_amount, full_color) {
      var black_hex, code, i, num_bars, raw_num_bars, remainder, _i, _ref, _results;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      raw_num_bars = Math.min(1.0, current_amount / max_amount) * max_tiles;
      num_bars = Math.ceil(raw_num_bars);
      remainder = num_bars - raw_num_bars;
      code = null;
      _results = [];
      for (i = _i = 0, _ref = max_tiles - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i === num_bars - 1) {
          if (remainder < 0.25) {
            code = Brew.unicode.block_full;
          } else if (remainder < 0.5) {
            code = Brew.unicode.block_threequarter;
          } else if (remainder < 0.75) {
            code = Brew.unicode.block_half;
          } else {
            code = Brew.unicode.block_quarter;
          }
          _results.push(this.drawOnPanel(panel_name, start_x + i, start_y, code, ROT.Color.toHex(full_color)));
        } else if (i < num_bars) {
          code = Brew.unicode.block_full;
          _results.push(this.drawOnPanel(panel_name, start_x + i, start_y, code, ROT.Color.toHex(full_color)));
        } else {
          _results.push(this.drawOnPanel(panel_name, start_x + i, start_y, " ", black_hex));
        }
      }
      return _results;
    },
    drawBarOnPanel: function(panel_name, start_x, start_y, max_tiles, current_amount, max_amount, full_color) {
      var black_hex, fadecolor, i, num_bars, raw_num_bars, remainder, tile, violet_rgb, _i, _ref;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      raw_num_bars = Math.min(1.0, current_amount / max_amount) * max_tiles;
      num_bars = Math.ceil(raw_num_bars);
      remainder = num_bars - raw_num_bars;
      tile = null;
      for (i = _i = 0, _ref = max_tiles - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i === num_bars - 1) {
          if (remainder < 0.25) {
            fadecolor = full_color;
          } else if (remainder < 0.5) {
            fadecolor = ROT.Color.interpolate(full_color, Brew.colors.normal, 0.25);
          } else if (remainder < 0.75) {
            fadecolor = ROT.Color.interpolate(full_color, Brew.colors.normal, 0.5);
          } else {
            fadecolor = ROT.Color.interpolate(full_color, Brew.colors.normal, 0.75);
          }
          this.drawOnPanel(panel_name, start_x + i, start_y, " ", "white", ROT.Color.toHex(full_color));
        } else if (i < num_bars) {
          this.drawOnPanel(panel_name, start_x + i, start_y, " ", "white", ROT.Color.toHex(full_color));
        } else {
          this.drawOnPanel(panel_name, start_x + i, start_y, " ", "white", ROT.Color.toHex(Brew.colors.normal));
        }
      }
      violet_rgb = ROT.Color.toHex(full_color);
      return this.drawTextOnPanel(panel_name, start_x + max_tiles + 1, start_y, "%c{" + violet_rgb + "}" + current_amount + "%c{" + black_hex + "}_");
    },
    drawTextBarOnPanel: function(panel_name, start_x, start_y, max_tiles, current_amount, max_amount, full_color, text) {
      var black_hex, full_rgb, i, num_bars, raw_num_bars, remainder, text_char, tile, _i, _ref;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      raw_num_bars = Math.min(1.0, current_amount / max_amount) * max_tiles;
      num_bars = Math.ceil(raw_num_bars);
      remainder = num_bars - raw_num_bars;
      tile = null;
      for (i = _i = 0, _ref = max_tiles - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i < text.length) {
          text_char = text[i];
        } else {
          text_char = " ";
        }
        if (i < num_bars) {
          this.drawOnPanel(panel_name, start_x + i, start_y, text_char, "white", ROT.Color.toHex(full_color));
        } else {
          this.drawOnPanel(panel_name, start_x + i, start_y, text_char, "white", ROT.Color.toHex(Brew.colors.normal));
        }
      }
      full_rgb = ROT.Color.toHex(full_color);
      return this.drawTextOnPanel(panel_name, start_x + max_tiles + 1, start_y, "%c{" + full_rgb + "}" + current_amount + "%c{" + black_hex + "}_");
    },
    getPanelAt: function(xy) {
      var panel_name;
      panel_name = "dunno";
      if (xy.y < Brew.panels.game.height) {
        panel_name = "game";
      } else {
        panel_name = "playerinfo";
      }
      return panel_name;
    },
    centerViewOnPlayer: function() {
      var half_x, half_y, view_x, view_y;
      if (Brew.gameLevel().width <= Brew.panels.game.width && Brew.gameLevel().height <= Brew.panels.game.height) {
        return;
      }
      half_x = my_display.getOptions().width / 2;
      half_y = my_display.getOptions().height / 2;
      view_x = Math.min(Math.max(0, Brew.gamePlayer().coordinates.x - half_x), Brew.gameLevel().width - Brew.panels.game.width);
      view_y = Math.min(Math.max(0, Brew.gamePlayer().coordinates.y - half_y), Brew.gameLevel().height - Brew.panels.game.height);
      return my_view = new Coordinate(view_x, view_y);
    },
    drawGamePanel: function(options) {
      var col_x, row_y, screen_xy, _i, _ref, _ref1, _results;
      _results = [];
      for (row_y = _i = _ref = Brew.panels.game.y, _ref1 = Brew.panels.game.y + Brew.panels.game.height - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; row_y = _ref <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _ref3, _results1;
          _results1 = [];
          for (col_x = _j = _ref2 = Brew.panels.game.x, _ref3 = Brew.panels.game.x + Brew.panels.game.width - 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; col_x = _ref2 <= _ref3 ? ++_j : --_j) {
            screen_xy = new Coordinate(col_x, row_y);
            _results1.push(Brew.Display.drawGamePanelAt(screen_xy, null, options));
          }
          return _results1;
        })());
      }
      return _results;
    },
    drawMapAtList: function(map_xy_list, options) {
      var map_xy, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = map_xy_list.length; _i < _len; _i++) {
        map_xy = map_xy_list[_i];
        if (Brew.gameLevel().checkValid(map_xy)) {
          _results.push(Brew.Display.drawMapAt(map_xy, options));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    drawMapAt: function(map_xy, options) {
      var screen_xy;
      screen_xy = Brew.Display.mapToScreen(map_xy);
      if (screen_xy != null) {
        return Brew.Display.drawGamePanelAt(screen_xy, null, options);
      }
    },
    drawGamePanelAt: function(xy, map_xy, options) {
      var c, can_view_and_lit, color_mod, draw, feature, fromMemory, h, in_view, is_lit, item, item_color, lighted, map_key, map_title, map_val, memory, mob_color, monster, over_saturate, overhead, pathmap, prelighting_draw, r, terrain, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      color_mod = (_ref = options != null ? options.color_mod : void 0) != null ? _ref : [0, 0, 0];
      over_saturate = (_ref1 = options != null ? options.over_saturate : void 0) != null ? _ref1 : false;
      map_xy = Brew.Display.screenToMap(xy);
      if (map_xy == null) {
        console.log(xy);
        return;
      }
      if (!Brew.gameLevel().checkValid(map_xy)) {
        console.error(map_xy);
        return;
      }
      if (Brew.Debug.pathmaps.index != null) {
        _ref2 = Brew.Debug.pathmaps.list[Brew.Debug.pathmaps.index], map_title = _ref2[0], pathmap = _ref2[1];
        map_val = pathmap[map_xy.toKey()];
        if (map_val === MAX_INT) {
          return;
        } else if (map_val < 0) {
          c = Math.round(255 * (map_val / pathmap.min_value), 0);
        } else {
          c = Math.round(255 * (1 - (map_val / pathmap.max_value)), 0);
        }
        r = map_val === 0 ? 255 : 0;
        my_display.draw(xy.x, xy.y, " ", 'black', ROT.Color.toHex([r, c, c]));
        return;
      }
      in_view = Brew.gamePlayer().canView(map_xy);
      lighted = Brew.gameLevel().getLightAt(map_xy);
      if (debug.fov.monster != null) {
        in_view = debug.fov.monster.canView(map_xy);
        lighted = Brew.colors.light_blue;
      }
      map_key = map_xy.toKey();
      if ((Brew.Game.dummy_fov != null) && (Brew.Game.dummy_fov.fov[map_key] != null) && Brew.Game.dummy_fov.fov[map_key]) {
        lighted = Brew.colors.monster_fov;
      }
      memory = Brew.gamePlayer().getMemoryAt(Brew.gameLevel().id, map_xy);
      terrain = Brew.gameLevel().getTerrainAt(map_xy);
      feature = Brew.gameLevel().getFeatureAt(map_xy);
      overhead = Brew.gameLevel().getOverheadAt(map_xy);
      fromMemory = false;
      draw = [];
      prelighting_draw = [null, null, null];
      is_lit = (lighted != null) || (debug_monster_fov === true);
      can_view_and_lit = (in_view && is_lit) || map_xy.compare(Brew.gamePlayer().coordinates);
      Brew.Display.clearDisplayAt(my_layer_display, xy);
      if (!can_view_and_lit) {
        if (memory == null) {
          draw = [" ", Brew.colors.black, Brew.colors.black];
        } else {
          fromMemory = true;
          draw = [memory.code, Brew.colors.memory, Brew.colors.memory_bg];
        }
      } else {
        if (terrain == null) {
          debugger;
        }
        item = Brew.gameLevel().getItemAt(map_xy);
        monster = Brew.gameLevel().getMonsterAt(map_xy);
        if (monster != null) {
          Brew.gamePlayer().setMemoryAt(Brew.gameLevel().id, map_xy, terrain);
          if (monster.hasFlag(Brew.flags.on_fire.id)) {
            mob_color = Brew.colors.hf_orange;
          } else if (monster.hasFlag(Brew.flags.is_stunned.id)) {
            mob_color = Brew.colors.light_blue;
          } else if (monster.hasFlag(Brew.flags.poisoned.id)) {
            mob_color = Brew.colors.dark_green;
          } else if (monster.hasFlag(Brew.flags.is_shielded.id)) {
            mob_color = Brew.colors.green;
          } else {
            mob_color = terrain.bgcolor;
          }
          draw = [monster.code, monster.color, mob_color];
        } else if (item != null) {
          Brew.gamePlayer().setMemoryAt(Brew.gameLevel().id, map_xy, item);
          item_color = Brew.Catalog.getItemColor(item);
          draw = [item.code, item_color, terrain.bgcolor];
        } else {
          Brew.gamePlayer().setMemoryAt(Brew.gameLevel().id, map_xy, terrain);
          draw = [terrain.code, terrain.color, terrain.bgcolor];
          if ((feature != null) && (feature.code != null)) {
            draw[0] = feature.code;
          }
          if ((feature != null) && (feature.color != null)) {
            draw[1] = ROT.Color.interpolate(terrain.color, feature.color, feature.intensity);
          } else if ((feature != null) && (feature.bgcolor != null)) {
            draw[2] = ROT.Color.interpolate(terrain.bgcolor, feature.bgcolor, feature.intensity);
          }
        }
        if (overhead != null) {
          my_layer_display.draw(xy.x, xy.y, overhead.code, ROT.Color.toHex(overhead.color));
        }
        prelighting_draw = draw.slice(0);
        if (over_saturate) {
          draw[1] = ROT.Color.multiply(lighted, draw[1]);
          draw[2] = ROT.Color.multiply(lighted, draw[2]);
        } else {
          draw[1] = Brew.utils.minColorRGB(ROT.Color.multiply(lighted, draw[1]), draw[1]);
          draw[2] = Brew.utils.minColorRGB(ROT.Color.multiply(lighted, draw[2]), draw[2]);
        }
      }
      if ((options != null ? options.color_override : void 0) != null) {
        draw[1] = options.color_override;
        draw[2] = Brew.colors.black;
      }
      h = Brew.Display.getHighlightAt(map_xy);
      if (h != null) {
        draw[2] = h;
      }
      return my_display.draw(xy.x, xy.y, draw[0], ROT.Color.toHex(draw[1]), ROT.Color.toHex(draw[2]));
    },
    drawHudAll: function() {
      Brew.Display.drawPlayerInfoPanel();
      return true;
    },
    drawPlayerInfoPanel: function() {
      var axe_col, black_hex, color, doom, equipped, hp, i, maxdoom, maxhp, maxstamina, offset, player, row, stamina, turn_str, _i, _j, _k, _ref;
      black_hex = ROT.Color.toHex(Brew.colors.black);
      player = Brew.gamePlayer();
      row = 0;
      maxstamina = player.getStat(Brew.stat.stamina).getMax();
      stamina = player.getStat(Brew.stat.stamina).getCurrent();
      for (i = _i = 1; 1 <= maxstamina ? _i <= maxstamina : _i >= maxstamina; i = 1 <= maxstamina ? ++_i : --_i) {
        color = i <= stamina ? Brew.colors.stamina : Brew.colors.normal;
        this.drawOnPanel("playerinfo", i - 1, row, Brew.unicode.block_full, ROT.Color.toHex(color));
      }
      axe_col = 7;
      equipped = player.inventory.getEquipped(Brew.equip_slot.melee);
      if (equipped != null) {
        this.drawOnPanel("playerinfo", axe_col, row, equipped.code, ROT.Color.toHex(equipped.color));
      } else {
        this.drawOnPanel("playerinfo", axe_col, row, "_", black_hex);
      }
      row = 0;
      maxhp = player.getStat(Brew.stat.health).getMax();
      hp = player.getStat(Brew.stat.health).getCurrent();
      for (i = _j = 1; 1 <= maxhp ? _j <= maxhp : _j >= maxhp; i = 1 <= maxhp ? ++_j : --_j) {
        if (player.hasFlag(Brew.flags.is_shielded.id)) {
          color = Brew.colors.player_shield;
        } else {
          color = i <= hp ? Brew.colors.health : Brew.colors.normal;
        }
        offset = Brew.panels.playerinfo.width - maxhp + i - 1;
        this.drawOnPanel("playerinfo", offset, row, Brew.unicode.heart, ROT.Color.toHex(color));
      }
      row += 1;
      turn_str = String(Brew.Game.turn);
      for (i = _k = 0, _ref = turn_str.length - 1; 0 <= _ref ? _k <= _ref : _k >= _ref; i = 0 <= _ref ? ++_k : --_k) {
        offset = Brew.panels.playerinfo.width - turn_str.length + i;
        this.drawOnPanel("playerinfo", offset, row, turn_str[i], ROT.Color.toHex(Brew.colors.white));
      }
      maxdoom = player.getStat(Brew.stat.doom).getMax();
      doom = player.getStat(Brew.stat.doom).getCurrent();
      return Brew.Display.drawSeparatedBarOnPanel("playerinfo", 0, row, 6, doom, maxdoom, Brew.colors.blood);
    },
    addMessage: function(text, turncount) {
      messagelog.push([text, turncount]);
      return true;
    },
    drawMessagesPanel: function() {
      return true;
    },
    updateTerrainFooter: function(old_xy, new_xy) {
      var article, i, message, new_t, old_t;
      message = "";
      i = Brew.gameLevel().getItemAt(new_xy);
      old_t = Brew.gameLevel().getTerrainAt(old_xy);
      new_t = Brew.gameLevel().getTerrainAt(new_xy);
      if (i != null) {
        article = Brew.Catalog.getArticleForItem(i);
        message = "There is " + article + (Brew.Catalog.getItemName(i)) + " here. (SPACE to pick up)";
      } else if ((!Brew.utils.sameDef(old_t, new_t)) && (new_t.walkover != null)) {
        message = new_t.walkover;
      }
      if (message !== "") {
        return this.drawFooterPanel(message);
      }
    },
    drawFooterPanel: function(message) {
      return true;
    },
    drawOnScreenInfo: function() {
      var code_hex_color, count_hex_color, def_id, flag, flag_list, flag_text, i, item, item_hex_color, level, mob, mob_hex_color, net_items, net_monsters, onscreen_html, player, scroll_item_list, scroll_type, terrain_hex_color, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      player = Brew.gamePlayer();
      level = Brew.gameLevel();
      onscreen_html = "";
      onscreen_html += "<p><span style='color: yellow'>Temple level " + (Brew.gameLevel().depth + 1) + " of " + Brew.config.max_depth + "</p>";
      onscreen_html += "<p><strong>Inventory</strong></p>";
      i = 1;
      _ref = Brew.Axe.getScrollStack();
      for (scroll_type in _ref) {
        scroll_item_list = _ref[scroll_type];
        if (scroll_item_list.length === 0) {
          code_hex_color = ROT.Color.toHex(Brew.colors.half_white);
          count_hex_color = ROT.Color.toHex(Brew.colors.half_white);
        } else {
          code_hex_color = ROT.Color.toHex(Brew.Catalog.getItemColor(scroll_item_list[0]));
          count_hex_color = ROT.Color.toHex(Brew.colors.white);
        }
        onscreen_html += "<p>[" + i + "] <span style='color: " + code_hex_color + "'>" + Brew.group.scroll.code + "</span> <span style='color: " + count_hex_color + "'>" + scroll_item_list.length + "</span> " + Brew.ItemType.type_of.scroll[scroll_type].real_name + " </p>";
        i += 1;
      }
      onscreen_html += "<br/>";
      onscreen_html += "<p><strong>In View</strong></p>";
      net_items = {};
      _ref1 = level.getItems();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        item = _ref1[_i];
        if (player.hasKnowledgeOf(item) || item.coordinates.compare(player.coordinates)) {
          net_items[item.def_id] = item;
        }
      }
      for (def_id in net_items) {
        if (!__hasProp.call(net_items, def_id)) continue;
        item = net_items[def_id];
        item_hex_color = ROT.Color.toHex(Brew.Catalog.getItemColor(item));
        onscreen_html += "<p><span style='color: " + item_hex_color + "'>" + item.code + "</span> - " + (Brew.Catalog.getItemName(item)) + "</p>";
      }
      onscreen_html += "<br/>";
      net_monsters = {};
      _ref2 = level.getMonsters();
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        mob = _ref2[_j];
        if (Brew.utils.compareThing(mob, player)) {
          continue;
        }
        if (player.hasKnowledgeOf(mob)) {
          net_monsters[mob.def_id] = mob;
        }
      }
      for (def_id in net_monsters) {
        if (!__hasProp.call(net_monsters, def_id)) continue;
        mob = net_monsters[def_id];
        mob_hex_color = ROT.Color.toHex(mob.color);
        onscreen_html += "<p><span style='color: " + mob_hex_color + "'>" + mob.code + "</span> - " + mob.name;
        onscreen_html += (" (" + (mob.getStat(Brew.stat.health).getMax()) + ": <span style='color: red'>") + ((function() {
          var _k, _ref3, _results;
          _results = [];
          for (i = _k = 1, _ref3 = mob.getStat(Brew.stat.health).getMax(); 1 <= _ref3 ? _k <= _ref3 : _k >= _ref3; i = 1 <= _ref3 ? ++_k : --_k) {
            _results.push(Brew.unicode.heart);
          }
          return _results;
        })()).join("") + "</span>)";
        onscreen_html += "</p>";
        onscreen_html += "<p>" + mob.description + "</p>";
        flag_list = [];
        _ref3 = mob.getFlags();
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          flag = _ref3[_k];
          flag_list.push(Brew.flags[flag].desc_enemy);
        }
        flag_text = flag_list.join(", ");
        onscreen_html += "<p>" + flag_text + "</p>";
        onscreen_html += "<br/>";
      }
      if ((level.exit_xy != null) && Brew.utils.isTerrain(level.getTerrainAt(level.exit_xy), "STAIRS_DOWN")) {
        terrain_hex_color = ROT.Color.toHex(level.getTerrainAt(level.exit_xy).color);
        onscreen_html += "<p><span style='color: " + terrain_hex_color + "'>" + (level.getTerrainAt(level.exit_xy).code) + "</span> - Level Exit</p>";
      }
      $("#id_div_onscreeninfo").html(onscreen_html);
      return true;
    },
    clearDisplay: function(display) {
      return display._context.clearRect(0, 0, display.getContainer().width, display.getContainer().height);
    },
    clearLayerDisplay: function() {
      return Brew.Display.clearDisplay(my_layer_display);
    },
    clearDialogDisplay: function() {
      return Brew.Display.clearDisplay(my_dialog_display);
    },
    clearDisplayAt: function(display, xy) {
      var x, y;
      x = xy.x * my_tile_width;
      y = xy.y * my_tile_height;
      return display._context.clearRect(x, y, my_tile_width, my_tile_height);
    },
    showFloatingTextAbove: function(loc_xy, msg, color_rgb) {
      var above_xy, xy, _i, _len, _ref;
      if (color_rgb == null) {
        color_rgb = Brew.colors.white;
      }
      above_xy = loc_xy.y === 0 ? loc_xy.add(new Coordinate(0, 1)) : loc_xy.subtract(new Coordinate(0, 1));
      if (above_xy.compare(Brew.gamePlayer().coordinates)) {
        _ref = above_xy.getAdjacent();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          xy = _ref[_i];
          if (Brew.gameLevel().checkValid(xy)) {
            above_xy = xy;
            break;
          }
        }
      }
      return Brew.Display.showFloatingText(above_xy, msg, color_rgb);
    },
    showFloatingText: function(loc_xy, msg, color_rgb) {
      var color_hex, dialog_xy, far_right, offset, x, y;
      if (color_rgb == null) {
        color_rgb = Brew.colors.white;
      }
      color_hex = ROT.Color.toHex(color_rgb);
      dialog_xy = this.gameToDialog(loc_xy);
      far_right = dialog_xy.x + msg.length;
      if (far_right >= Brew.config.dialog_display.width) {
        offset = far_right - Brew.config.dialog_display.width;
        dialog_xy = dialog_xy.subtract(new Coordinate(offset, 0));
      }
      my_dialog_display.drawText(dialog_xy.x, dialog_xy.y, "%c{" + color_hex + "}" + msg);
      x = dialog_xy.x * my_dialog_tile_width;
      y = dialog_xy.y * my_dialog_tile_height;
      return setTimeout((function(_this) {
        return function() {
          return my_dialog_display._context.clearRect(x, y, my_dialog_tile_width * msg.length, my_dialog_tile_height * 2);
        };
      })(this), Brew.config.floating_text_timeout);
    }
  };

  initLayerDisplay = function() {
    var pos;
    pos = $(my_display.getContainer()).position();
    $("#id_div_layer").css({
      position: "absolute",
      top: pos.top,
      left: pos.left
    });
    Brew.Display.clearLayerDisplay();
    return $("#id_div_layer").show();
  };

  initDialogDisplay = function() {
    var pos;
    pos = $(my_display.getContainer()).position();
    $("#id_div_dialog").css({
      position: "absolute",
      top: pos.top,
      left: pos.left
    });
    Brew.Display.clearDialogDisplay();
    return $("#id_div_dialog").show();
  };

}).call(this);

//# sourceMappingURL=display.map
